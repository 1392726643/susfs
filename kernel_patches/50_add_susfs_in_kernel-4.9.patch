diff --git a/fs/Makefile b/fs/Makefile
index 0e97f4b85bee4..610ba6cf0e49c 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -13,6 +13,9 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		pnode.o splice.o sync.o utimes.o \
 		stack.o fs_struct.o statfs.o fs_pin.o nsfs.o
 
+obj-$(CONFIG_KSU_SUSFS) += susfs.o
+obj-$(CONFIG_KSU_SUSFS_SUS_SU) += sus_su.o
+
 ifeq ($(CONFIG_BLOCK),y)
 obj-y +=	buffer.o block_dev.o direct-io.o mpage.o
 else
diff --git a/fs/internal.h b/fs/internal.h
index 3e58863de5144..4fe0133cc4f6e 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -74,6 +74,10 @@ extern int __mnt_want_write_file(struct file *);
 extern void __mnt_drop_write(struct vfsmount *);
 extern void __mnt_drop_write_file(struct file *);
 
+#ifdef CONFIG_KSU_SUSFS
+int path_umount(struct path *path, int flags);
+#endif
+
 /*
  * fs_struct.c
  */
diff --git a/fs/mount.h b/fs/mount.h
index 3603884a63ddb..e654136a7e9e5 100644
--- a/fs/mount.h
+++ b/fs/mount.h
@@ -64,6 +64,13 @@ struct mount {
 	__u32 mnt_fsnotify_mask;
 #endif
 	int mnt_id;			/* mount identifier */
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	bool is_sus_mount;
+#endif
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	int fake_mnt_id;
+	int fake_mnt_master_group_id;
+#endif
 	int mnt_group_id;		/* peer group identifier */
 	int mnt_expiry_mark;		/* true if marked for expiry */
 	struct hlist_head mnt_pins;
diff --git a/fs/namei.c b/fs/namei.c
index 0cbf8f5a92f44..df551f11f898e 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -42,6 +42,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /* [Feb-1997 T. Schoebel-Theuer]
  * Fundamental changes in the pathname lookup mechanisms (namei)
  * were necessary because of omirr.  The reason is that omirr needs
@@ -2186,6 +2190,10 @@ static int link_path_walk(const char *name, struct nameidata *nd)
 			}
 			return -ENOTDIR;
 		}
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+		if (!err && unlikely(nd->path.dentry->d_inode->is_sus_path))
+			return 0;
+#endif
 	}
 }
 
@@ -3621,6 +3629,15 @@ struct file *do_filp_open(int dfd, struct filename *pathname,
 
 	set_nameidata(&nd, dfd, pathname);
 	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (!IS_ERR(filp)) {
+		if (unlikely(filp->f_inode->is_sus_path && uid_matches_suspicious_path())) {
+			filp = ERR_PTR(filp->f_inode->sus_path_err_retval.other_syscalls);
+			restore_nameidata();
+			return filp;
+		}
+	}
+#endif
 	if (unlikely(filp == ERR_PTR(-ECHILD)))
 		filp = path_openat(&nd, op, flags);
 	if (unlikely(filp == ERR_PTR(-ESTALE)))
@@ -3827,6 +3844,14 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const char __user *, filename, umode_t, mode,
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.mknodat;
+		done_path_create(&path, dentry);
+		return error;
+	}
+#endif
+
 	if (!IS_POSIXACL(path.dentry->d_inode))
 		mode &= ~current_umask();
 	error = security_path_mknod(&path, dentry, mode, dev);
@@ -3904,6 +3929,13 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const char __user *, pathname, umode_t, mode)
 	if (IS_ERR(dentry))
 		return PTR_ERR(dentry);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.mkdirat;
+		done_path_create(&path, dentry);
+		return error;
+	}
+#endif
 	if (!IS_POSIXACL(path.dentry->d_inode))
 		mode &= ~current_umask();
 	error = security_path_mkdir(&path, dentry, mode);
@@ -3982,6 +4014,14 @@ static long do_rmdir(int dfd, const char __user *pathname)
 	if (IS_ERR(name))
 		return PTR_ERR(name);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.rmdir;
+		path_put(&path);
+		putname(name);
+		return error;
+	}
+#endif
 	switch (type) {
 	case LAST_DOTDOT:
 		error = -ENOTEMPTY;
@@ -4118,6 +4158,14 @@ static long do_unlinkat(int dfd, const char __user *pathname)
 	if (IS_ERR(name))
 		return PTR_ERR(name);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.unlinkat;
+		path_put(&path);
+		putname(name);
+		return error;
+	}
+#endif
 	error = -EISDIR;
 	if (type != LAST_NORM)
 		goto exit1;
@@ -4235,6 +4283,13 @@ SYSCALL_DEFINE3(symlinkat, const char __user *, oldname,
 	if (IS_ERR(dentry))
 		goto out_putname;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.symlinkat_newname;
+		done_path_create(&path, dentry);
+		goto out_putname;
+	}
+#endif
 	error = security_path_symlink(&path, dentry, from->name);
 	if (!error)
 		error = vfs_symlink2(path.mnt, path.dentry->d_inode, dentry, from->name);
@@ -4377,12 +4432,27 @@ SYSCALL_DEFINE5(linkat, int, olddfd, const char __user *, oldname,
 	if (error)
 		return error;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(old_path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = old_path.dentry->d_inode->sus_path_err_retval.linkat_oldname;
+		goto out;
+	}
+#endif
+
 	new_dentry = user_path_create(newdfd, newname, &new_path,
 					(how & LOOKUP_REVAL));
 	error = PTR_ERR(new_dentry);
 	if (IS_ERR(new_dentry))
 		goto out;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(new_path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = new_path.dentry->d_inode->sus_path_err_retval.linkat_newname;
+		done_path_create(&new_path, new_dentry);
+		goto out;
+	}
+#endif
+
 	error = -EXDEV;
 	if (old_path.mnt != new_path.mnt)
 		goto out_dput;
@@ -4641,6 +4711,15 @@ SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
 		goto exit;
 	}
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(old_path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = old_path.dentry->d_inode->sus_path_err_retval.renameat2_oldname;
+		path_put(&old_path);
+		putname(from);
+		goto exit;
+	}
+#endif
+
 	to = user_path_parent(newdfd, newname,
 				&new_path, &new_last, &new_type, lookup_flags);
 	if (IS_ERR(to)) {
@@ -4648,6 +4727,17 @@ SYSCALL_DEFINE5(renameat2, int, olddfd, const char __user *, oldname,
 		goto exit1;
 	}
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(new_path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = new_path.dentry->d_inode->sus_path_err_retval.renameat2_newname;
+		path_put(&new_path);
+		putname(to);
+		path_put(&old_path);
+		putname(from);
+		goto exit;
+	}
+#endif
+
 	error = -EXDEV;
 	if (old_path.mnt != new_path.mnt)
 		goto exit2;
diff --git a/fs/open.c b/fs/open.c
index f2b82c462fbba..2916cda07c38c 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -34,6 +34,10 @@
 
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 int do_truncate2(struct vfsmount *mnt, struct dentry *dentry, loff_t length,
 		unsigned int time_attrs, struct file *filp)
 {
@@ -147,6 +151,13 @@ static long do_sys_truncate(const char __user *pathname, loff_t length)
 retry:
 	error = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);
 	if (!error) {
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.other_syscalls;
+		path_put(&path);
+		return error;
+	}
+#endif
 		error = vfs_truncate(&path, length);
 		path_put(&path);
 	}
@@ -415,6 +426,15 @@ SYSCALL_DEFINE3(faccessat, int, dfd, const char __user *, filename, int, mode)
 	if (res)
 		goto out;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		res = path.dentry->d_inode->sus_path_err_retval.other_syscalls;
+		path_put(&path);
+		revert_creds(old_cred);
+		put_cred(override_cred);
+		return res;
+	}
+#endif
 	inode = d_backing_inode(path.dentry);
 	mnt = path.mnt;
 
@@ -471,6 +491,13 @@ SYSCALL_DEFINE1(chdir, const char __user *, filename)
 	error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
 	if (error)
 		goto out;
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.other_syscalls;
+		path_put(&path);
+		return error;
+	}
+#endif
 
 	error = inode_permission2(path.mnt, path.dentry->d_inode, MAY_EXEC | MAY_CHDIR);
 	if (error)
diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c
index 0fa95bc5950aa..04918c3b685f1 100644
--- a/fs/overlayfs/dir.c
+++ b/fs/overlayfs/dir.c
@@ -152,6 +152,11 @@ static int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,
 	if (err)
 		return err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+	if (realpath.dentry->d_inode->is_sus_kstat)
+		goto bypass_orig_flow;
+#endif
+
 	stat->dev = dentry->d_sb->s_dev;
 	stat->ino = dentry->d_inode->i_ino;
 
@@ -163,6 +168,10 @@ static int ovl_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,
 	if (OVL_TYPE_MERGE(type))
 		stat->nlink = 1;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+bypass_orig_flow:
+#endif
+
 	return 0;
 }
 
diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c
index ae1b42489ddd1..ffddbb54b2d42 100644
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@ -265,17 +265,25 @@ bool ovl_is_whiteout(struct dentry *dentry)
 
 const struct cred *ovl_override_creds(struct super_block *sb)
 {
+#ifdef CONFIG_KSU_SUSFS
+	return NULL;
+#else
 	struct ovl_fs *ofs = sb->s_fs_info;
 
 	if (!ofs->config.override_creds)
 		return NULL;
 	return override_creds(ofs->creator_cred);
+#endif
 }
 
 void ovl_revert_creds(const struct cred *old_cred)
 {
+#ifdef CONFIG_KSU_SUSFS
+	return;
+#else
 	if (old_cred)
 		revert_creds(old_cred);
+#endif
 }
 
 static bool ovl_is_opaquedir(struct dentry *dentry)
diff --git a/fs/proc/base.c b/fs/proc/base.c
index b6959f6dae5b3..9665ef85f7780 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -97,6 +97,10 @@
 
 #include "../../lib/kstrtox.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /* NOTE:
  *	Implementing inode permission operations in /proc is almost
  *	certainly an error.  Permission checks need to happen during
@@ -1828,6 +1832,15 @@ static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)
 	char *pathname;
 	int len;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	struct mm_struct *mm;
+	struct vm_area_struct *vma;
+	struct file *vma_file;
+	struct dentry *vma_dentry;
+	struct inode *vma_inode;
+	unsigned long ino;
+#endif
+
 	if (!tmp)
 		return -ENOMEM;
 
@@ -1839,6 +1852,38 @@ static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)
 
 	if (len > buflen)
 		len = buflen;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+	if (!susfs_is_sus_proc_fd_link_list_empty()) {
+		if (susfs_sus_proc_fd_link(pathname, len))
+			goto orig_flow;
+	}
+#endif
+
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (!susfs_is_sus_maps_list_empty()) {
+		mm = current->mm;
+		down_read(&mm->mmap_sem);
+		for (vma = mm->mmap; vma; vma = vma->vm_next) {
+			if (vma->vm_file) {
+				vma_file = vma->vm_file;
+				vma_dentry = vma_file->f_path.dentry;
+				if (vma_dentry == path->dentry) {
+					vma_inode = file_inode(vma_file);
+					ino = vma_inode->i_ino;
+					susfs_sus_map_files_readlink(ino, pathname);
+					break;
+				}
+			}
+		}
+		up_read(&mm->mmap_sem);
+	}
+#endif
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+orig_flow:
+#endif
 	if (copy_to_user(buffer, pathname, len))
 		len = -EFAULT;
  out:
@@ -2207,6 +2252,9 @@ struct map_files_info {
 	fmode_t		mode;
 	unsigned long	len;
 	unsigned char	name[4*sizeof(long)+2]; /* max: %lx-%lx\0 */
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	int susfs_action;
+#endif
 };
 
 /*
@@ -2269,6 +2317,10 @@ static struct dentry *proc_map_files_lookup(struct inode *dir,
 	int result;
 	struct mm_struct *mm;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	int ret = 0;
+#endif
+
 	result = -ENOENT;
 	task = get_proc_task(dir);
 	if (!task)
@@ -2291,6 +2343,23 @@ static struct dentry *proc_map_files_lookup(struct inode *dir,
 	if (!vma)
 		goto out_no_vma;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (vma->vm_file) {
+		ret = susfs_sus_map_files_instantiate(vma);
+		if (ret == 1) {
+			if (vma->vm_file->f_mode & FMODE_WRITE) {
+				vma->vm_file->f_mode &= ~FMODE_WRITE;
+			}
+			goto orig_flow;
+		}
+		if (ret == 2) {
+			result = -ENOENT;
+			goto out_no_vma; 
+		}
+	}
+orig_flow:
+#endif
+
 	if (vma->vm_file)
 		result = proc_map_files_instantiate(dir, dentry, task,
 				(void *)(unsigned long)vma->vm_file->f_mode);
@@ -2322,6 +2391,10 @@ proc_map_files_readdir(struct file *file, struct dir_context *ctx)
 	struct map_files_info *p;
 	int ret;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	int susfs_ret = 0;
+#endif
+
 	ret = -ENOENT;
 	task = get_proc_task(file_inode(file));
 	if (!task)
@@ -2380,6 +2453,12 @@ proc_map_files_readdir(struct file *file, struct dir_context *ctx)
 			info.len = snprintf(info.name,
 					sizeof(info.name), "%lx-%lx",
 					vma->vm_start, vma->vm_end);
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+			susfs_ret = susfs_sus_map_files_instantiate(vma);
+			info.susfs_action = susfs_ret;
+#endif
+
 			if (flex_array_put(fa, i++, &info, GFP_KERNEL))
 				BUG();
 		}
@@ -2388,12 +2467,28 @@ proc_map_files_readdir(struct file *file, struct dir_context *ctx)
 
 	for (i = 0; i < nr_files; i++) {
 		p = flex_array_get(fa, i);
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+		if (p->susfs_action == SUSFS_MAP_FILES_ACTION_REMOVE_WRITE_PERM) {
+			if (p->mode & FMODE_WRITE) {
+				p->mode &= ~FMODE_WRITE;
+			}
+		} else if (p->susfs_action == SUSFS_MAP_FILES_ACTION_HIDE_DENTRY) {
+			goto skip_proc_fill_cache;
+		}
+#endif
+
 		if (!proc_fill_cache(file, ctx,
 				      p->name, p->len,
 				      proc_map_files_instantiate,
 				      task,
 				      (void *)(unsigned long)p->mode))
 			break;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+skip_proc_fill_cache:
+#endif
+
 		ctx->pos++;
 	}
 	if (fa)
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index f4a77817ad74c..147e75d2a88b6 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -22,6 +22,10 @@
 #include <asm/tlbflush.h>
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 void task_mem(struct seq_file *m, struct mm_struct *mm)
 {
 	unsigned long text, lib, swap, ptes, pmds, anon, file, shmem;
@@ -358,9 +362,26 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 	unsigned long start, end;
 	dev_t dev = 0;
 	const char *name = NULL;
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	char *out_name;
+	int ret = 0;
+#endif
 
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
+#if defined(CONFIG_KSU_SUSFS_SUS_KSTAT) && !defined(CONFIG_KSU_SUSFS_SUS_MAPS)
+		// when sus_kstat is used but sus_maps is disabled, sus_kstat should take care the ino & dev of the spoofed inode in maps as well
+		// when both sus_kstat and sus_maps is enabled, user should use both to spoof the ino & dev of the target file
+		if (unlikely(inode->is_sus_kstat)) {
+			dev = inode->sus_kstat.dev;
+			ino = inode->sus_kstat.ino;
+			pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
+			start = vma->vm_start;
+			end = vma->vm_end;
+			show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
+			goto kstat_bypass_orig_flow;
+		}
+#endif
 		dev = inode->i_sb->s_dev;
 		ino = inode->i_ino;
 		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
@@ -369,12 +390,35 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 	/* We don't show the stack guard page in /proc/maps */
 	start = vma->vm_start;
 	end = vma->vm_end;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	out_name = kmalloc(SUSFS_MAX_LEN_PATHNAME, GFP_KERNEL);
+	if (!out_name)
+		goto orig_flow;
+	ret = susfs_sus_maps(ino, end - start, &ino, &dev, &flags, &pgoff, vma, out_name);
+
+orig_flow:
+#endif
+
 	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (ret == 2) {
+		seq_pad(m, ' ');
+		seq_puts(m, out_name);
+		seq_putc(m, '\n');
+		kfree(out_name);
+		return;
+	}
+	kfree(out_name);
+#endif
 	/*
 	 * Print the dentry name for named mappings, and a
 	 * special [heap] marker for the heap:
 	 */
+#if defined(CONFIG_KSU_SUSFS_SUS_KSTAT) && !defined(CONFIG_KSU_SUSFS_SUS_MAPS)
+kstat_bypass_orig_flow:
+#endif
 	if (file) {
 		seq_pad(m, ' ');
 		seq_file_path(m, file, "\n");
diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c
index 6863773aff252..c980aed358a97 100644
--- a/fs/proc_namespace.c
+++ b/fs/proc_namespace.c
@@ -15,6 +15,10 @@
 #include "pnode.h"
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 static unsigned mounts_poll(struct file *file, poll_table *wait)
 {
 	struct seq_file *m = file->private_data;
@@ -99,6 +103,11 @@ static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (unlikely(r->is_sus_mount))
+		return SEQ_SKIP;
+#endif
+
 	if (sb->s_op->show_devname) {
 		err = sb->s_op->show_devname(m, mnt_path.dentry);
 		if (err)
@@ -135,8 +144,23 @@ static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)
 	struct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (unlikely(r->is_sus_mount))
+		return SEQ_SKIP;
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (!uid_matches_proc_need_to_reorder_mnt_id())
+		goto orig_flow;
+	seq_printf(m, "%i %i %u:%u ", r->fake_mnt_id, r->mnt_parent->fake_mnt_id,
+				MAJOR(sb->s_dev), MINOR(sb->s_dev));
+	goto bypass_orig_flow;
+orig_flow:
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 	seq_printf(m, "%i %i %u:%u ", r->mnt_id, r->mnt_parent->mnt_id,
 		   MAJOR(sb->s_dev), MINOR(sb->s_dev));
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+bypass_orig_flow:
+#endif
 	if (sb->s_op->show_path) {
 		err = sb->s_op->show_path(m, mnt->mnt_root);
 		if (err)
@@ -158,11 +182,15 @@ static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)
 	if (IS_MNT_SHARED(r))
 		seq_printf(m, " shared:%i", r->mnt_group_id);
 	if (IS_MNT_SLAVE(r)) {
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+		seq_printf(m, " master:%i", r->fake_mnt_master_group_id);
+#else
 		int master = r->mnt_master->mnt_group_id;
 		int dom = get_dominating_id(r, &p->root);
 		seq_printf(m, " master:%i", master);
 		if (dom && dom != master)
 			seq_printf(m, " propagate_from:%i", dom);
+#endif
 	}
 	if (IS_MNT_UNBINDABLE(r))
 		seq_puts(m, " unbindable");
@@ -199,6 +227,11 @@ static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (unlikely(r->is_sus_mount))
+		return SEQ_SKIP;
+#endif
+
 	/* device */
 	if (sb->s_op->show_devname) {
 		seq_puts(m, "device ");
diff --git a/fs/readdir.c b/fs/readdir.c
index 1059f2a9be0b2..4f011a77cdb2e 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -21,6 +21,10 @@
 
 #include <asm/uaccess.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 int iterate_dir(struct file *file, struct dir_context *ctx)
 {
 	struct inode *inode = file_inode(file);
@@ -301,6 +305,13 @@ static int filldir64(struct dir_context *ctx, const char *name, int namlen,
 	buf->error = -EINVAL;	/* only used if we fail.. */
 	if (reclen > buf->count)
 		return -EINVAL;
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (!susfs_is_sus_path_list_empty() && uid_matches_suspicious_path()) {
+		if (unlikely(susfs_sus_ino_for_filldir64(ino))) {
+			return 0;
+		}
+	}
+#endif
 	dirent = buf->previous;
 	if (dirent) {
 		if (signal_pending(current))
diff --git a/fs/stat.c b/fs/stat.c
index 068fdbcc9e26a..5018f4074b41c 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -18,6 +18,10 @@
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 void generic_fillattr(struct inode *inode, struct kstat *stat)
 {
 	stat->dev = inode->i_sb->s_dev;
@@ -64,11 +68,33 @@ EXPORT_SYMBOL(vfs_getattr_nosec);
 
 int vfs_getattr(struct path *path, struct kstat *stat)
 {
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+	struct inode *inode;
+#endif
 	int retval;
 
 	retval = security_inode_getattr(path);
 	if (retval)
 		return retval;
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+	inode = path->dentry->d_inode;
+	if (unlikely(inode->is_sus_kstat)) {
+		stat->dev = inode->sus_kstat.dev;
+		stat->ino = inode->sus_kstat.ino;
+		stat->mode = inode->sus_kstat.mode;
+		stat->nlink = inode->sus_kstat.nlink;
+		stat->uid = inode->sus_kstat.uid;
+		stat->gid = inode->sus_kstat.gid;
+		stat->rdev = inode->sus_kstat.rdev;
+		stat->size = inode->sus_kstat.size;
+		stat->atime = inode->sus_kstat.atime;
+		stat->mtime = inode->sus_kstat.mtime;
+		stat->ctime = inode->sus_kstat.ctime;
+		stat->blksize = inode->sus_kstat.blksize;
+		stat->blocks = inode->sus_kstat.blocks;
+		return 0;
+	}
+#endif
 	return vfs_getattr_nosec(path, stat);
 }
 
@@ -80,6 +106,13 @@ int vfs_fstat(unsigned int fd, struct kstat *stat)
 	int error = -EBADF;
 
 	if (f.file) {
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(f.file->f_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = f.file->f_inode->sus_path_err_retval.other_syscalls;
+		fdput(f);
+		return error;
+	}
+#endif
 		error = vfs_getattr(&f.file->f_path, stat);
 		fdput(f);
 	}
@@ -106,6 +139,13 @@ int vfs_fstatat(int dfd, const char __user *filename, struct kstat *stat,
 	error = user_path_at(dfd, filename, lookup_flags, &path);
 	if (error)
 		goto out;
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		error = path.dentry->d_inode->sus_path_err_retval.other_syscalls;
+		path_put(&path);
+		return error;
+	}
+#endif
 
 	error = vfs_getattr(&path, stat);
 	path_put(&path);
@@ -328,6 +368,13 @@ SYSCALL_DEFINE4(readlinkat, int, dfd, const char __user *, pathname,
 	if (!error) {
 		struct inode *inode = d_backing_inode(path.dentry);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+		if (unlikely(inode->is_sus_path && uid_matches_suspicious_path())) {
+			error = inode->sus_path_err_retval.other_syscalls;
+			path_put(&path);
+			return error;
+		}
+#endif
 		error = empty ? -ENOENT : -EINVAL;
 		if (inode->i_op->readlink) {
 			error = security_inode_readlink(path.dentry);
diff --git a/fs/statfs.c b/fs/statfs.c
index 083dc0ac91408..68eaf37310900 100644
--- a/fs/statfs.c
+++ b/fs/statfs.c
@@ -57,7 +57,22 @@ static int statfs_by_dentry(struct dentry *dentry, struct kstatfs *buf)
 	retval = security_sb_statfs(dentry);
 	if (retval)
 		return retval;
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (unlikely(dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+		return dentry->d_inode->sus_path_err_retval.other_syscalls;
+	}
+#endif
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTATFS
+	if (unlikely(dentry->d_inode->is_sus_kstatfs)) {
+		memcpy(buf, &dentry->d_inode->sus_kstatfs, sizeof(struct kstatfs));
+		retval = 0;
+		goto bypass_orig_flow;
+	}
+#endif
 	retval = dentry->d_sb->s_op->statfs(dentry, buf);
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTATFS
+bypass_orig_flow:
+#endif
 	if (retval == 0 && buf->f_frsize == 0)
 		buf->f_frsize = buf->f_bsize;
 	return retval;
@@ -68,8 +83,16 @@ int vfs_statfs(struct path *path, struct kstatfs *buf)
 	int error;
 
 	error = statfs_by_dentry(path->dentry, buf);
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTATFS
+	if (!error) {
+		if (unlikely(path->dentry->d_inode->is_sus_kstatfs))
+			return error;
+		buf->f_flags = calculate_f_flags(path->mnt);
+	}
+#else
 	if (!error)
 		buf->f_flags = calculate_f_flags(path->mnt);
+#endif
 	return error;
 }
 EXPORT_SYMBOL(vfs_statfs);
@@ -82,6 +105,13 @@ int user_statfs(const char __user *pathname, struct kstatfs *st)
 retry:
 	error = user_path_at(AT_FDCWD, pathname, lookup_flags, &path);
 	if (!error) {
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+		if (unlikely(path.dentry->d_inode->is_sus_path && uid_matches_suspicious_path())) {
+			error = path.dentry->d_inode->sus_path_err_retval.other_syscalls;
+			path_put(&path);
+			return error;
+		}
+#endif
 		error = vfs_statfs(&path, st);
 		path_put(&path);
 		if (retry_estale(error, lookup_flags)) {
@@ -97,6 +127,13 @@ int fd_statfs(int fd, struct kstatfs *st)
 	struct fd f = fdget_raw(fd);
 	int error = -EBADF;
 	if (f.file) {
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+		if (unlikely(f.file->f_inode->is_sus_path && uid_matches_suspicious_path())) {
+			error = f.file->f_inode->sus_path_err_retval.other_syscalls;
+			fdput(f);
+			return error;
+		}
+#endif
 		error = vfs_statfs(&f.file->f_path, st);
 		fdput(f);
 	}
diff --git a/include/linux/fs.h b/include/linux/fs.h
index bb94ab942b66c..0a2f1efc75648 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -38,6 +38,13 @@
 #include <asm/byteorder.h>
 #include <uapi/linux/fs.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTATFS
+#include <linux/statfs.h>
+#endif // CONFIG_KSU_SUSFS_SUS_KSTATFS
+#endif // CONFIG_KSU_SUSFS
+
 struct backing_dev_info;
 struct bdi_writeback;
 struct export_operations;
@@ -737,6 +744,19 @@ struct inode {
 	struct list_head	i_fsverity_list;	/* Not for upstream */
 #endif
 	void			*i_private; /* fs or device private pointer */
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	bool is_sus_path;
+	struct st_sus_path_err_retval sus_path_err_retval;
+#endif
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+	struct kstat sus_kstat;
+	bool is_sus_kstat;
+#endif
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTATFS
+	struct kstatfs sus_kstatfs;
+	bool is_sus_kstatfs;
+#endif
 };
 
 static inline unsigned int i_blocksize(const struct inode *node)
diff --git a/kernel/fork.c b/kernel/fork.c
index a0988fcb62cd6..9aa8e3ffdcc92 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -94,6 +94,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /*
  * Minimum number of threads to boot the kernel
  */
@@ -1996,6 +2000,10 @@ static __latent_entropy struct task_struct *copy_process(
 	trace_task_newtask(p, clone_flags);
 	uprobe_copy_process(p, clone_flags);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	susfs_sus_mount(p->nsproxy->mnt_ns);
+#endif
+
 	return p;
 
 bad_fork_cancel_cgroup:
@@ -2407,6 +2415,10 @@ SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)
 	if (err)
 		goto bad_unshare_cleanup_cred;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	susfs_sus_mount(new_nsproxy->mnt_ns);
+#endif
+
 	if (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {
 		if (do_sysvsem) {
 			/*
diff --git a/kernel/sys.c b/kernel/sys.c
index a7f8232245463..b4ef430350a98 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -66,6 +66,10 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a, b)	(-EINVAL)
 #endif
@@ -1148,7 +1152,14 @@ SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
 	struct new_utsname tmp;
 
 	down_read(&uts_sem);
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+	if (likely(!susfs_spoof_uname(&tmp)))
+		goto bypass_orig_flow;
+#endif
 	memcpy(&tmp, utsname(), sizeof(tmp));
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+bypass_orig_flow:
+#endif
 	up_read(&uts_sem);
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
diff --git a/mm/shmem.c b/mm/shmem.c
index 9cb863a19d074..f91b4b4595ca2 100644
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@ -33,6 +33,9 @@
 #include <linux/swap.h>
 #include <linux/uio.h>
 #include <linux/khugepaged.h>
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
 
 static struct vfsmount *shm_mnt;
 
@@ -3562,6 +3565,13 @@ SYSCALL_DEFINE2(memfd_create,
 		goto err_name;
 	}
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MEMFD
+	if (susfs_sus_memfd(name)) {
+		error = -EFAULT;
+		goto err_name;
+	}
+#endif
+
 	fd = get_unused_fd_flags((flags & MFD_CLOEXEC) ? O_CLOEXEC : 0);
 	if (fd < 0) {
 		error = fd;
